# 工厂模式（Factory Pattern）

我们在创建一个对象时，通常都是使用 new() 的方法。这样会导致当发生变化时，我们需要去修改代码，增加具体的实例或者删除不用的实例。而我们不应该针对实现编程，设计应该“对扩展开放，对修改关闭”。

工厂（factory）处理创建对象的细节。

## 简单工厂

简单工厂其实不是一个设计模式，反而比较像是一种编程习惯。

![比萨店类图](http://q8id96pmj.bkt.clouddn.com/img/比萨店类图.jpg)

## 认识工厂方法模式

**所有工厂模式都用来封装对象的创建**。工厂方法模式（Factory Method Pattern）通过让子类决定该创建的对象是什么，来达到将对象创建的过程封装的目的。

- 创建者类

  抽象创建者类定义了一个抽象的工厂方法，让子类实现此方法制造产品。

  创建者通常会包含依赖于抽象产品的代码，而这些抽象产品由子类制造。创建者不需要真的知道在制造哪种具体产品。

- 产品类

  工厂生产产品。由具体的产品继承自抽象产品类，可以更好地扩展。

## 定义工厂方法模式

**工厂方法模式**定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。

所谓的“决定”，并不是指模式允许子类本身在运行时做决定，而是指在编写创建者类时，不需要知道实际创建的产品是哪一个。选择了使用哪个子类，自然就决定了实际创建的产品是什么。

## 对象依赖

当你直接实例化一个对象时，就是在依赖它的具体类。

### 依赖倒置原则（Dependency Inversion Principle）

- **设计原则：要依赖抽象，不要依赖具体类**

  不能让高层组件依赖低层组件，而且，不管高层或低层组件，“两者”都应该依赖于抽象。

- **依赖倒置原则，究竟倒置在哪里？**

  低层组件依赖高层的抽象，同样地，高层组件现在也依赖相同的抽象。

- **倒置你的思考方式**（e.g.要实现一个比萨店）

  - 原来思考方式
    1. 比萨店要进行准备、烘烤、装盒，所以比萨店要能制作不同口味的比萨。
    2. 开始考虑不同口味的比萨店
  - 倒置后的思考方式
    1. 从比萨开始，不同口味的比萨都是比萨，所以它们应该共享一个比萨接口
    2. 现在回过头来思考如何设计比萨店？比萨店已经不用关注具体口味的比萨了，可以依靠一个工厂来将这些具体类取出比萨店。这样一来，比萨店依赖的就是抽象的比萨。

遵循几个原则可以避免在OO设计中违反依赖倒置原则：

- **变量不可以持有具体类的引用**

- **不要让类派生自具体类**

  如果派生自具体类，你就会依赖具体类。请派生自一个抽象（接口或抽象类）

- **不要覆盖基类中已实现的方法**

## 定义抽象工厂模式

抽象工厂模式提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。

抽象工厂允许客户使用抽象的接口来创建一组相关的产品，而不需要知道（或关心）实际产出的具体产品是什么。这样一来，客户就从具体的产品中被解耦。让我们看看类图来了解其中的关系：

![抽象工厂模式类图](http://q8id96pmj.bkt.clouddn.com/img/抽象工厂模式类图.jpg)

在抽象工厂中，利用工厂方法实现生产方法是相当自然的做法。

## 比较工厂方法和抽象工厂

- 创建对象方式
  - 工厂方法通过子类重写创建方法来创建对象。
  - 抽象工厂提供了一个用来创建一个产品家族的抽象类型，这个类型的子类定义了产品被产生的方法。
- 新增一个产品时
  - 工厂方法只需要扩展一个新的产品子类并重写工厂方法就可以。
  - 抽象工厂则需要改变接口，因为它是被用来创建整个产品家族的。

当你需要创建**产品家族和想让制造的相关产品集合**起来时，可以使用抽象工厂。

这两种模式都是**将对象创建的过程封装起来**，以便将代码从具体类解耦。

